\section{Introduction}\label{sec:introduction}

Ownership has been paid growing attention by researches on type systems because ownership type systems add safety and expressiveness to programming language systems. Reachability type system \langstar \cite{reachability-paper} is one of the promising works, which extends the simply-typed $\lambda$-calculus typing system with mutable references by introducing a qualifier to track the set of its reachable free variables. 

In syntax, the \langstar system has an additional type qualifier in the type system to track the variables that the term may reach. However, the qualifier is implemented on the finite set and the behavior of the qualifier lacks  clear formalization. One remarkable weak point of the set implementation is that the expressive power of finite set is either limited or unnecessary. Namely, if we only use the set inclusion, the extension would be hard because the set inclusion is not expressive enough to represent a set of complex tracking rules. Some attempts on extending the \langstar system such as the must-reachability tracking extension \cite{must-reachability} have shown the lack of expressive power of set qualifiers, i.e. the set inclusion is not able to represent a tracking interval. Meanwhile, the original \langstar work has introduced set equality to handle the general cases that self-references are included in the typing rules, which is a weak point of the work because the base is no longer pure sets with only inclusion. 

In order to clearly formalize the expected behavior of the qualifier and select proper base theory behind, we come up with the idea of syntactic qualifier based on a set of axiomatic rules. Instead of using an existing structure, we start the qualifier with a set of pre-defined rules and construct anything else using the set of rules, so that the qualifier is axiomatic. One remarkable advantage compared with the original set version is that the potential expressive power, i.e. the scope able to represent, is limited by the axiomatic rules, thus we can choose a proper set of base rules for different extension variants. 

Intersection and union type \cite{intersection-union-types} is a set-theoretic type system, which represents sets of values by logical combinators. Intersection type, \texttt{$\tau \land \sigma$} means a value is both \texttt{$\tau$} and \texttt{$\sigma$}. While the duality, union type \texttt{$\tau \lor \sigma$} means a value is either \texttt{$\tau$} or \texttt{$\sigma$}.


We presents a syntactic reachability tracking qualifier for the \langstar system as a substitution to the set qualifier in the original work \cite{reachability-paper}. The syntactic qualifier is based on the idea of intersection and union types, which is saying that the sub-qualifier relations come from the subtyping in the intersection and union typing system. We expect the syntactic qualifier to have the same expressive power as the set qualifier that would be able to maintain the type safety proof of the \langstar system.

In summary, the report contains following content: 
\begin{itemize}
    \item We provide an informal technique overview of the syntactic qualifier design (Section \ref{sec:overview}).
    \item We summarize the current progress and difficulties in the attempt (Section \ref{sec:progress}) 
    \item We discuss the potential problems in the current design and next steps (Section \ref{sec:discussion}) 
    % \item We formally present the typing rules of the \lambdaintv system, as an extension to the \langstar typing system \cite{reachability-paper} (Section \ref{sec:typing-rules}).
    % \item We discuss the difficulties in the work and next steps to solve the problems (Section \ref{sec:discussion}).
\end{itemize}


% Ownership has been paid growing attention by researches on type systems because ownership type systems indeed add safety and expressiveness to programming language systems. As a milestone, Rust \cite{rust-paper} language is the first programming language for practical use with ownership system. Ownership style systems generally enforce safety by posting uniqueness restrictions on sharing, for example only one unique mutable reference or multiple read-only references are permitted in Rust, which in return inspires new effect systems. 

% Even though many works are done on ownership type systems, the mainstream limits to the imperative style analysis and only a few breakthroughs are made on higher-order language features. Reachability type system \langstar \cite{reachability-paper} is one of the promising works in the less focused field, which extends the simply-typed $\lambda$-calculus typing system with mutable references by introducing a qualifier to track the set of its reachable free variables. By embedding the reachability tracking in types, the greatest advantage is that the system enables ownership-style reasoning for higher-order functional features. However, there exists one limitation in the reachability types work that the effect system only cares ``kill'' effects and leaves ``gen'' effects. 

% Contrary to ``kill'' effects that forbids accessing after ``kill'', ``gen'' effects ensure the valid initialization for resources (i.e. variables, objects, etc) for some certain properties. Object initialization is a typical and popular case for ``gen'' effects because operations on objects may only be valid if every field is properly initialized. There are some existing works attempting to add initialization effect system to programming languages supporting higher-order features, such as Scala. One recent work $\iota$DOT \cite{iDOT} guarantees safe initialization for objects in Scala as an extension to the Dependent Object Types (DOT) calculus \cite{dot-paper}, the formal foundation for Scala language. The $\iota$Dot system statically prevents reading uninitialized objects by assigning ``free'' (not fully initialized) and ``committed'' (fully initialized) initialization types while making definite assignment of fields in the effect system. The free and committed objects are stored in two separate subheaps so that properly initialized objects can only access properly initialized objects. 

% There raises an interesting question that can we encode ``gen'' effects in the reachability type system \langstar? Intuitively, since the ``gen'' effect is the inverse of ``kill'' effect and \langstar already tracks separation for higher-order functional programs, we are able to define a similar tracking but on top of strict-reachability in the scheme of \langstar. The work follows the extension strategy described in the \langstar work \cite{reachability-paper} as a possible future work for must-reach tracking.

% We present a type system, \lambdaintv, which extends the \langstar reachability type system \cite{reachability-paper} by extending the reachability qualifiers to reachability intervals. With the reachability intervals, the system is now able to track both the must-reachable variables and may-reachable variables at the same time, i.e. the lower bound and the upper bound of the actual reachable set. The must-reachability qualifier, as our main contribution added to the original system, is designed by the duality that naturally exists between the strict-reachablity tracking and the nonstrict-reachability tracking. The extended system is formalized in Coq and we expect to prove the safety theorems of the extended system, i.e. progress and preservation theorem. Note that currently the progress theorem has been proved but the preservation theorem is still in progress.

% In summary, this paper presents contributions including:
% \begin{itemize}
%     \item We informally present the extension from reachability qualifiers to reachability intervals and introduce the duality between must-reachability and may-reachability (Section \ref{sec:overview}).
%     \item We formally present the typing rules of the \lambdaintv system, as an extension to the \langstar typing system \cite{reachability-paper} (Section \ref{sec:typing-rules}).
%     \item We discuss the difficulties in the work and next steps to solve the problems (Section \ref{sec:discussion}).
% \end{itemize}

